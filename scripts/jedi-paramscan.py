#/bin/python
import os, sys, argparse
import numpy as np

__author__ = 'Jordi Juarez-Jimenez'

def read_paramfile (paramfile):
    '''(str)-> dict

    Reads the keywords and values for JEDI parameters from paramfile

    '''
    info = "INFO: Reading JEDI parameters from file %s" % paramfile
    print(info)
    parameters = {}
    try:
         with open(paramfile) as f:
            while True:
                line = f.readline()
                if line == '':
                    break
                elif '#' in line:
                    continue
                else:
                    mor = line.split('=')
                    key = mor[0].lower().replace(' ','')
                    temp= mor[1].split(';')
                    value = float(temp[0])
                    parameters[key] = value

         return parameters           

    
    except FileNotFoundError:
        print("ERROR: File %s was not found" % paramfile )
        sys.exit()

def modify_parameter (paramid, newvalue, parameters):
    '''(str, float, dict) -> dict

    Sets the value of paramid in parameters to newvalue

    '''
    try:
        parameters[paramid.lower()] = newvalue
        #print(parameters)
        return parameters
    except KeyError:
        print("ERROR: It was not possible to set value %.2f for parameter %s " % (newvalue, paramid))
        sys.exit()


def get_default_value (parmid, parameters):
    '''(str, dict) -> float 

    Returns the value of parmid stored in parameters.

    '''
    print('INFO: Scanning values for parameter: %s' % parmid)
    try:
        default_value = parameters[parmid.lower()]
        return default_value
    except KeyError:
        print("ERROR: The parameter %s was not present in the input file" % parmid)
        sys.exit()

def write_paramfile (newparams, scanparam, newparamfile):
    '''(dict, str, str) -> None

    Writes a JEDI parameter file named newparamfile with values stored in newparams

    '''
    try:
        with open(newparamfile, 'w') as f:
            header = '''# JEDI parameter set generated by jedi-paramscan.py
# The value of %s has been modified.
# The remaining values are taken from Cuchillo et. al. JCTC 2015, Table 2
# Feb 2016 Emin/deltaE values modified for better MD stability
# Feb 2016 GP1_min GP2_min & deltaGP1/GP2 replaced by GP_min & GP_max\n''' % scanparam
            f.write(header)
            lines = [['alpha', newparams['alpha'], 'PLS slope active volume'],
                     ['beta', newparams['beta'], 'PLS slope hydrophobicity'],
                     ['gamma', newparams['gamma'], 'PLS constant'],
                     ['CC_mind', newparams['cc_mind'], 'distance (nm) below which a grid point is fully in close contact with the protein'],
                     ['deltaCC', newparams['deltacc'], 'interval (nm) over which a grid point is in partial contact with the protein'],
                     ['Emin', newparams['emin'], 'exposure value from which s_on_exposure starts to be >0'],
                     ['deltaE', newparams['deltae'], 'interval over which the s_on_exposure value reaches 1.0'],
                     ['BSmin' , newparams['bsmin'], 'minimum distance (nm) between a grid point and binding site atoms below which the maximal activity is fixed to 1'],
                     ['deltaBS', newparams['deltabs'], 'interval (nm) over which the maximal activity of a grid point decreases to 0'],
                     ['theta', newparams['theta'], 'constant used for minium distance calculation (rescales grid point activities with respect to ligand position)'],
                     ['CC2_min', newparams['cc2_min'], 'minimum distance (nm) below which a grid point is overlapping the protein (for exposure calculation)'],
                     ['deltaCC2', newparams['deltacc2'], 'interval (nm) over which a grid point is in partial contact with the protein (for exposure calculation)'],
                     ['GP_min', newparams['gp_min'], 'distance (nm) above which a grid point is considered for exposure calculation'],
                     ['GP_max', newparams['gp_max'], 'distance (nm) below which a grid point is considered for exposure calculation'],
                     ['r_hydro', newparams['r_hydro'], 'distance (nm) below which a grid point is fully in close contact with the protein (for hydrophobicity calculation)'],
                     ['deltar_hydro', newparams['deltar_hydro'], 'interval interval over which a grid point is in partial contact with the protein (for hydrophobicity calculation)'],
                     ['V_max', newparams['v_max'], 'volume (cubic nm) below which Vdruglike is equal to 1'],
                     ['deltaV_max', newparams['deltav_max'],'volume interval (cubic nm) over which Vdruglike goes from 1 to 0'],
                     ['V_min', newparams['v_min'], 'volume (cubic nm) below which Vdruglike is equal to 0'],
                     ['deltaV_min', newparams['deltav_min'],'volume interval (cubic nm) over which Vdruglike goes from 0 to 1'],
                     ['grid_resolution', newparams['grid_resolution'], 'Space (nm) between two adjacent grid points']
                    ]
            for line in lines:
                f.write("%s = %8.3f ;      %s\n" % (line[0].ljust(20), line[1], line[2]) )
    except KeyError:
        print("ERROR: The JEDI input file contained non standard parameters")
        sys.exit()
    
                




if __name__ == '__main__':

    # Parse mandatory arguments
    parser = argparse.ArgumentParser(description="Scan values for JEDI parameters")
    parser.add_argument('-parameter', metavar='-p', type=str, required=True, help="JEDI parameter to scan")
    #scanparam = 'deltaE'
    # These are optional arguments. Default values listed below 
    parser.add_argument('--parameter_file', type=str, required=False, default='jedi.params', help="File from which default values for JEDI parameters will be read. Default is jedi.params")
    parser.add_argument('--scan_margin', type=float, required=False, default=0.20, 
                        help="The width of the scan as a 0.0 to 1.0 fraction of the default value (DV). The scan will be performed between DV-(DV*scan_margin) and DV+(DV*scan_margin)")
    parser.add_argument('--number_of_windows', type=int, required=False, default=10, help= "The number of different values that will be scanned" )
    args = parser.parse_args()
    scanparam = args.parameter
    paramfile = args.parameter_file
    var_margin = args.scan_margin
    num_of_tests = args.number_of_windows
    #End of parser
    
    parameters = read_paramfile(paramfile)
    default_value = get_default_value(scanparam, parameters)
    
    lowbound = default_value - (default_value*var_margin)
    highbound= default_value + (default_value*var_margin) 
    sample_values = np.linspace(lowbound,highbound, num=num_of_tests)

    out_parameter_scan = []
    
    for value in sample_values:
        modparam = modify_parameter(scanparam, value, parameters)
        strvalue = "%.3f" % modparam[scanparam.lower()]
        paramfilename = paramfile.split('.')[0]  + '-scan-' + scanparam + '-' + strvalue + '.' + paramfile.split('.')[1]
        write_paramfile(modparam, scanparam, paramfilename)
        out_parameter_scan.append(modparam)
    print ('INFO: All done!')